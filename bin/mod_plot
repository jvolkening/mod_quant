#!/usr/bin/env perl

use strict;
use warnings;
use 5.012;

use File::Which;
use Getopt::Long;
use List::Util qw/any sum/;
use List::MoreUtils qw/uniq/;
use BioX::Seq::Fetch;

my $PROGRAM = 'mod_plot';
my $VERSION = 0.001;

my $GNUPLOT_BIN =
        which('gnuplot5')
     // which('gnuplot')
     // die "ERROR: gnuplot is required but not found\n";

# parse input parameters and config file
my $protein;
my $fn_fasta;
my $fn_quant;
my $prefix;
my $order;
my $ylim       = 1.2;
my $label_psms = 0;
my $shade_psms = 0;
my $min_psms   = 0;
my $star_met   = 0;
my $min_coord;
my $max_coord;

GetOptions(
    'protein=s'   => \$protein,
    'fasta=s'     => \$fn_fasta,
    'quant=s'     => \$fn_quant,
    'prefix=s'    => \$prefix,
    'order=s'     => \$order,
    'ylim=f'      => \$ylim,
    'label_psms'  => \$label_psms,
    'shade_psms'  => \$shade_psms,
    'min_psms=i'  => \$min_psms,
    'star_met'    => \$star_met,
    'min_coord=i' => \$min_coord,
    'max_coord=i' => \$max_coord,
);

my $seqs = BioX::Seq::Fetch->new($fn_fasta);
my $seq = $seqs->fetch_seq($protein) // die "failed to find $protein in fasta\n";
$seq = uc $seq;

open my $quant, '<', $fn_quant;
my $header = <$quant>;
chomp $header;
my @parts = split "\t", $header;
die "invalid header format\n" if $parts[0] ne '#peptide';
die "invalid header format\n" if $parts[1] ne 'protein';

my $fields;
my @samples;
my @n;

for (2..$#parts) {
    my $key = $parts[$_];
    my ($base, $n, $type) = ( $key =~ /^(.+)\.(\d+)\.(mean|sd|psms|quant)$/ );
    die "invalid header field: $key\n" if (! defined $type);
    push @samples, $base;
    push @n, $n if ($n > 0);
    $fields->{$n}->{$base}->{$type} = $_;
}

@n = sort {$a <=> $b} uniq @n;
@samples = uniq @samples;
@samples = split(',', $order) if (defined $order);

open my $stream, '|-', $GNUPLOT_BIN;

my $i = 0;
my @peptides;
my @blocks;
LINE:
while (my $line = <$quant>) {
    chomp $line;
    my @parts = split "\t", $line;
    next LINE if $parts[1] ne $protein;
    my $start;
    my $end;
    if ($seq =~ /$parts[0]/) {
        $start = $-[0] + 1; 
        $end = $+[0];
    }
    else {
        warn "$parts[0] not found in protein\n";
        next LINE;
    }

    # check coordinate range
    next LINE if (defined $min_coord && $start < $min_coord);
    next LINE if (defined $max_coord && $end   > $max_coord);

    my $star = ($star_met && $parts[0] =~ /M/)
        ? '*'
        : '';
    my $name = "$start - $end$star";
    push @peptides, $name;

    my $id = '$h' . $i++;

    my $block;

    open my $stream, '>', \$block;

    say {$stream} "$id << EOD";
    say {$stream} join "\t", 'mods', @n, 'sum', 'sd', 'psms';

    my $tot_psms = 0;

    for my $sample (@samples) {
        my $psms = 0;
        my $sd   = 0;
        my @means;
        NMOD:
        for my $n (0, @n) {
            
            $psms += defined $fields->{$n}->{$sample}->{psms}
                ? @parts[ $fields->{$n}->{$sample}->{psms} ]
                : 0;
            next NMOD if ($n == 0);
            my $sdt = defined $fields->{$n}->{$sample}->{sd} 
                ? @parts[ $fields->{$n}->{$sample}->{sd} ]
                : 0;
            $sd += $sdt eq 'NA' ? 0 : $sdt;
            my $mu = defined $fields->{$n}->{$sample}->{mean}
                ? @parts[ $fields->{$n}->{$sample}->{mean} ]
                : 0;
            push @means, ($mu eq 'NA' ? 0 : $mu);
        }
        my $name = $sample;
        $name =~ s/^$prefix// if (defined $prefix);
        $name =~ s/_/\\\\_/g;
        $tot_psms += $psms;
        say {$stream} join "\t",
            $name,
            @means,
            sum(@means),
            $sd,
            $psms;
    }
    
    say {$stream} "EOD";

    close $stream;

    next LINE if ($tot_psms < $min_psms);

    push @blocks, [$start, $end, $id, $name, $block, $tot_psms];

}

@blocks = sort {
        $a->[0] <=> $b->[0]
     || $a->[1] <=> $b->[1]
} @blocks;

for (@blocks) {
    print {$stream} $_->[4];
}


my $n_samples = scalar @samples;
my $n_n = scalar(@n) + 1;
my $t = $n_n + 1;
my $s = $n_n + 2;
my $p = $n_n + 3;

my $width = ($n_samples * 20) * scalar(@blocks) + 155;
my $cb_x = ($width-60)/$width;
my $cb_w = 10/$width;

my @shading;
my @hists;
for my $j (0..$#blocks) {

    my $o = $j * ($n_samples + 1);
    my $o1 = $o - 1;
    my $o2 = $o + $n_samples;
    my $use_title = $j == 0 ? '' : 'notitle';
    my $bl = $blocks[$j];

    my $lbl_str = $label_psms
        ? ",  '' using (\$0+$o):(\$$t+\$$s+0.04):$p with labels left rotate notitle"
        : '';

    push @hists, <<"BLOCK"
newhistogram "{/:Bold*1.2 $bl->[3]}" lt 1, '$bl->[2]' using 2:xtic(1) $use_title \\
 noenhanced, for [i=3:$n_n] '' using i $use_title, '' using (\$0+$o):$t:$s with yerrorbars \\
 notitle pt 0 lc rgb '#000000' lw 1 $lbl_str, \\
BLOCK
;

    push @shading, "set arrow from $o2,0 to $o2,$ylim nohead lc rgb 'black'\n";
    if ($shade_psms) {
        my $k = $j + 1;
        my $f = $bl->[5]/100;
        $f = $f > 1 ? 1 : $f;
        push @shading, "set object $k rectangle from $o1,0 to $o2,$ylim fillcolor palette cb $bl->[5] lw 0 behind\n";
    }

}

my $cb_block = $shade_psms
    ? <<"BLOCK"
set colorbox user origin $cb_x,.2 size $cb_w,.2
set cblabel "# PSMs"
set cbrange [0:50]
BLOCK
    : '';

print {$stream} cmd();
print {$stream} $_ for (@shading);
print {$stream} "plot \\\n";
print {$stream} $_ for (@hists);

sub cmd {

return <<"CMD"
set terminal svg size $width,300 enhanced fname 'FreeSans'  fsize 11 name "percent_mod" butt solid

# line styles
set linetype 1 lw 1 lc rgb '#E41A1C' # red
set linetype 2 lw 1 lc rgb '#377EB8' # blue
set linetype 3 lw 1 lc rgb '#4DAF4A' # green
set linetype 4 lw 1 lc rgb '#984EA3' # purple
set linetype 5 lw 1 lc rgb '#FF7F00' # orange
set linetype 6 lw 1 lc rgb '#FFFF33' # yellow
set linetype 7 lw 1 lc rgb '#A65628' # brown
set linetype 8 lw 1 lc rgb '#F781BF' # pink

set palette defined (0 '#ffffff', 1 '#999999')
set pm3d implicit
unset colorbox

$cb_block

set bar 1.000000 front
set boxwidth 0.9 absolute
set style fill   solid 1.00 border lt -1
set key outside right top vertical Left reverse noenhanced title autotitle columnhead title "# mods" nobox
set style histogram rowstacked title textcolor lt -1
#set style textbox transparent margins  1.0,  1.0 border
unset logscale
set style data histograms
set xtics border in scale 0,0 nomirror rotate by -55 offset -1,0 autojustify
set ytics nomirror
set title "{/:Bold*1.2 Percent Modification}" 
set ylabel "{/:Bold*1.2 fraction modified}"
set yrange [0:$ylim] noreverse nowriteback
set datafile separator "\t"
set bars 1.0
set offset graph 0.0, graph 0.0, graph 0.0, graph 0.0
CMD
;

}


__END__

=head1 NAME

mod_plot - produce single-protein figure from output of mod_quant

=head1 SYNOPSIS

mod_plot --config --sample_config samples.yaml <input_1.tsv> [<input_n.tsv>]

=head1 DESCRIPTION

C<mod_quant> parses tab-delimited output from an LC-MS/MS database search
containing quantification values and outputs ratios of peptide modifications
for the input samples.

=head1 PREREQUISITES

Requires the following non-core Perl libraries:

=over 1

=item * YAML::Tiny

=back

In addition, requires the following binaries installed on the system path:

=over 1

=item * gnuplot

=back

=head1 OPTIONS

=over 4

=item B<--config> I<filename>

Path to YAML file containing parsing configuration

=item B<--sample_config> I<filename>

Path to YAML file containing sample/replicate configuration

=item B<--parse_names>

If given, sample names will be parsed as follows:

=over 1

=item * suffixes (dot followed by 1-6 characters) are stripped

=item * the pattern "_Rn", where "n" is a positive integer, is looked for at
the end of the name. If found, it is stripped and the sample is assigned as
the "n"th replicate of the remaining sample name.

=back

As an example, the following name "experiment2_treated_R3.raw" would be parsed
as the 3rd replicate of sample "experiment2_treated".

This option is ignored if C<--sample_config> is specified.

=item B<--prefix>

If given, the prefix will be stripped from the beginning of sample names if
matching.

=back

=head1 CAVEATS AND BUGS

Please submit bug reports to the issue tracker in the distribution repository.

=head1 AUTHOR

Jeremy Volkening (jdv@base2bio.com)

=head1 LICENSE AND COPYRIGHT

Copyright 2014-17 Jeremy Volkening

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut

