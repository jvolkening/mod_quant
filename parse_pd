#!/usr/bin/env perl

use strict;
use warnings;
use 5.012;

use PerlIO::gzip;
use Data::Dumper;
use List::Util qw/sum/;
use List::MoreUtils qw/uniq/;

# this regex needs to match PD output format
my $re_ox = qr/^([A-Z])(\d+)\(OH[^\)]*\)$/;

# allow reading from gzipped files (with autodetect)
binmode STDIN, ":gzip(auto)";

# parse header
my $header = <STDIN>;
my @fields = extract_fields($header);

# track field names and indices
my %map;
@map{@fields} = (0..$#fields);

my $data;
my %peptides;
my %samples;

my $max_ox = 4;

# parse PSMs
while (my $line = <STDIN>) {

    my @values = extract_fields($line);

    # pre-set filters
    next if $values[ $map{'Confidence Level'} ] ne 'High';
    next if $values[ $map{'Rank'}             ] ne '1';
    next if $values[ $map{'Protein Group Accessions'} ] ne '000014';
    my $sample  =  $values[ $map{'Spectrum File'}  ];
    my $area    =  $values[ $map{'Precursor Area'} ];
    my $peptide =  uc $values[ $map{'Sequence'} ];
    next if (! length $area);

    # track unique peptides and samples
    $peptides{$peptide} = 1;
    $samples{$sample}   = 1;

    # handle mods
    # "R1(OH-ra); L3(OH-ra); A4(OH-raR0); R6(OH-ra)"
    my $n_ox = 0;
    my $mod_string = $values[  $map{Modifications} ];
    for my $mod (split /\s*;\s*/, $mod_string) {

        if ($mod =~ /$re_ox/) {
            my $aa  = $1;
            my $pos = $2;
            # do something with these values
            ++$n_ox;
        }

    }
    $n_ox = $max_ox if ($n_ox > $max_ox);
   
    push @{ $data->{$peptide}->{$sample}->{$n_ox} }, $area;

}

say '#', join "\t",
    '',
    map {$_, "\t" x ($max_ox-1)} sort keys %samples,
;
say '#', join "\t",
    'peptide',
    map {(0..$max_ox)} sort keys %samples,
;

for my $peptide (sort keys %peptides) {

    print "$peptide";

    for my $sample  (sort keys %samples)  {

        my @sums;
        for my $n_ox (0..$max_ox) {
            
            my $sum = defined $data->{$peptide}->{$sample}->{$n_ox}
                ? sum uniq @{ $data->{$peptide}->{$sample}->{$n_ox} }
                : 0;
            push @sums, $sum;

        }
        my $total = sum @sums;
        my @fracs = $total == 0
            ? map { 0         } 0..$#sums
            : map { $_/$total } @sums;
        print "\t", join "\t", @fracs;
    }
    print "\n";
}


exit;


#----------------------------------------------------------------------------#
#----------------------------------------------------------------------------#

sub extract_fields {

    #splits line on tabs and removes wrapping quotes, if any

    my ($line) = @_;
    chomp $line;
    return map {
        $_ =~ s/^"//;
        $_ =~ s/"$//;
        $_;
    } split "\t", $line;

};

